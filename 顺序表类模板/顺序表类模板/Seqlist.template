#include"Seqlist.h"
template<class T>
void Seqlist<T>::CheckCapacity()
{
	if (_size == _capacity)
	{
		size_t newcapacity = _capacity * 2;
		T* ptr = new T[newcapacity];
		memcpy(ptr, _array, sizeof(T)*_size);
		delete[] _array;
		_array = ptr;
		ptr = nullptr;
		_capacity = newcapacity;
	}
}
template<class T>
Seqlist<T>::Seqlist(int capacity)
	:_array(new T[capacity]),
	_capacity(capacity),
	_size(0)
{}
template<class T>
Seqlist<T>::~Seqlist()
{
	if (_array)
	{
		delete[] _array;
		_array = nullptr;
		_capacity = 0;
		_size = 0;
	}
}

template<class T>
void Seqlist<T>::PushBack(T data)
{
	CheckCapacity();
	_array[_size++] = data;
}
template<class T>
void Seqlist<T>::PopBack()
{
	if(_size>0)
	_size--;
}
template<class T>
void Seqlist<T>::PushFront(T data)
{
	CheckCapacity();
	int i = 0;
	for (i = _size-1; i >= 0; i--)
	{
		_array[i + 1] = _array[i];
	}
	_array[0] = data;
	_size++;
}
template<class T>
void Seqlist<T>::PopFront()
{
	int i = 0;
	for (i = 0; i < _size; i++)
	{
		_array[i] = _array[i + 1];
	}
	_size--;
}
template<class T>
void Seqlist<T>::SeqlistInsert(size_t pos,T data)
{
	CheckCapacity();
	int i = 0;
	for (i = pos; i < _size; i++)
	{
		_array[i + 1] = _array[i];
	}
	_array[pos] = data;
	_size++;
	
}
template<class T>
void Seqlist<T>::SeqlistErase(size_t pos)
{
	int i = 0;
	for (i = pos; i < _size; i++)
	{
		_array[i] = _array[i + 1];
	}
	_size--;
}
template<class T>
int Seqlist<T>::SeqlistFind(T data)
{
	int i = 0;
	for (i = 0; i < _size; i++)
	{
		if (_array[i] == data)
			return i;
	}
	return -1;
}
template<class T>
void Seqlist<T>::Remove(T data)
{
	int pos = 0;
	pos=SeqlistFind(data);
	if(pos!=-1)
	SeqlistErase(pos);
}
template<class T>
void Seqlist<T>::RemoveAll(T data)
{
	/*
	int i = 0;
	int j = 0;
	T* newarray = new T[_size];
	for (i = 0; i < _size; i++)
	{
		if (_array[i] != data)
		{
			newarray[j] = _array[i];
			j++;
		}
	}
	delete[] _array;
	_array = newarray;
	_size = j;
	newarray = nullptr;
	*/
	int i = 0;
	int j = 0;
	for (i = 0; i < _size; i++)
	{
		if (_array[i] == data)
			j++;
		else
			_array[i - j] = _array[i];
	}
	_size = _size - j;
}
template<class T>
size_t Seqlist<T>::Size()
{
	return _size;
}
template<class T>
size_t Seqlist<T>::Capacity()
{
	return _capacity;
}
template<class T>
int Seqlist<T>::Empty()
{
	return _size == 0;
}
template<class T>
T& Seqlist<T>::Front() const
{
	if(_size>0)
	return _array[0];
}
template<class T>
T& Seqlist<T>::Back() const
{
	return _array[_size];
}
template<class T>
T& Seqlist<T>::operator[](size_t pos) const
{
	assert(pos < _size);
	return _array[pos];
}

template<class T>
void Seqlist<T>::Print()
{
	int i = 0;
	for (i = 0; i < _size; i++)
	{
		cout << _array[i];
		cout << ' ';
	}
	cout << endl;
}
//int main()
//{
//	Seqlist<int> s;
//	s.PushBack(1);
//	s.PushBack(2);
//	s.PushBack(3);
//	s.PushBack(4);
//	s.PushBack(5);
//	s.Print();
//	s.PopBack();
//	s.PopBack();
//	s.Print();
//	s.PushFront(0);
//	s.Print();
//	s.PopFront();
//	s.Print();
//	s.SeqlistInsert(s.SeqlistFind(3), 4);
//	s.Print();
//	s.SeqlistErase(s.SeqlistFind(3));
//	s.Print();
//	s.Remove(2);
//	s.PushFront(2);
//	s.PushFront(2);
//	s.PushFront(2);
//	s.Print();
//	s.RemoveAll(2);
//	s.Print();
//	system("pause");
//	return 0;
//
//}